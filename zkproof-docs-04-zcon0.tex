\chapter[ZCon0]{ZKProof Workshop at ZCon0}
\label{chap:zcon0}

\textbf{Date:} 2018/06/27

\textbf{Speakers:} Daniel Benarroch, Eran Tromer, Muthu Venkitasubramaniam, Andrew Miller, Sean
Bowe, Nicola Greco, Izaak Meckler, Thibaut Schaeffer

\textbf{Note takers:} Arthur Prats, Vincent Cloutier and Daniel Benarroch


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session 1: Document Overview \& Feedback}
\label{sec:zcon0:session1-overview}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Intro --- Eran}
\label{sec:zcon0:session1-overview:intro}

The goal is to standardize the works of different parties working with SNARKs. Need to define
common methodology, definition, -- understand the trade off, to come up with a standard
This workshops are accompanied by documents. \myurl{Zkproof.org} to find those documents and it is
an open effort. Trying to get a mechanism to get feedback, this is also an open problem.

Want to help users specify what properties of SNARKs they want or need, so that clients can
ask practitioners possible things.

Libsnark comes from the academic world, but continued evolving outside academia. Contains
all the fancy features, like recursive composition and many gadgets. There is a dozen frontends
wrapping around libsnark. The gadget library is still competitive.

Snarky is a DSL written in OCaml. Written to be a functional replacement to libsnark, and to be
more integrated to avoid mistakes. Really inspired by the functional languages.

Making those librairies and others interoperable is a big goal of this workshop. Also making the
gadget reusable would be extremely useful.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Security --- Muthu Venkitasubramaniam}
\label{sec:zcon0:session1-overview:security}

\begin{itemize}[label={- }]
\item Simulation paradigm arised from original work
\item Every cryptog application can be modeled under a simulation agent --- can even reach ideal functionality
\item Provide a template for theoreticians or designers of systems to explain how zk and its properties are achieved.
\item Composability of cryptographic primitives implies need to use UC framework.
\item Language, terminology and notation (prover, witness, instance, etc.)
\item How to write statements
\item Clearly describe the properties of the scheme
\item Describe the setup of the ZK scheme
\item Specify the construction based on combinatorial vs cryptographic parts (interesting open problem to\luiscom{Something seemd to be missing here}
\item What are the assumptions and proving that the security is met.
\end{itemize}

{\bfseries Specification:}
\begin{itemize}[label={- }]
\item statements: bodeme or arithmetic circuit --- you should clearly specify how you represent your
statement. Should we add ram program? The consensus is no as there are too much changes
\item syntax / Alg: specify algorithms are in the proof: prove alg, verify algo, setup algo (sometimes
you can add trusted setup which can be included into setup) (setup: what kind of predicate,
parameters, what the is going in the prover, verifier)
\item properties --- those are local --– completeness sound and ZK
\item setup: trusted (structure reference string and a random reference string) and on trusted (there
is more here) what are the ramification,
\item construction: combinatorial part and cryptography part --- there is security implication in both
side
\item assumption (INISA in Europe)
\item[\hspace*{-1em}] (- efficiency that can potentially add here)
\end{itemize}

{\bfseries Security:}
\\Want to provide a template to follow in order to explain how their zero knowledge is written in
their paper (I want quantum, I do not want….) this is the motivation to start



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Applications --- Andrew Miller}
\label{sec:zcon0:session1-overview:apps}

The first draft of the \href{https://zkproof.org/ZKProof\%20Applications\%20Draft\%200.1.pdf}{document is online}

Three case studies:
\begin{itemize}[topsep=0pt,label={- }]
\item Asset tracking and transfer
\item Credential aggregation
\item Regulation compliance of supply chain
\end{itemize}


For each of the use-cases / apps we want to have modularity of building schemes (gadgets and
requirements) and focus on the security
\begin{itemize}[label={- }]
\item Desired security requirements and privacy goals
\item Introduce camenisch stadler notation for gadgets + zk functionality as black box
		\begin{itemize}[label={- }]
		\item None of the applications level description did not get into security parameter
					consideration / does not specify the program
		\item The specs are good to give to an implementation team and have them implement
					under the hood but not worry about the black boxes
		\end{itemize}
\item Describe the problem that the app solves
    \begin{itemize}[label={- }]
		\item Specify what is the public state, the witness, instance?
		\item Describe the predicate in english and technical terms
		\end{itemize}
\item Quests / Future work:
    \begin{itemize}[label={- }]
		\item Formal verification for snark applications
		\end{itemize}
\item Doc INCONSISTENCIES
    \begin{itemize}[label={- }]
    \item Abstraction of accumulator gadget vs specific merkle tree gadget
    \end{itemize}
\end{itemize}


{\bfseries Standardise on Camenisch-Stadler Notation}

Zk $\{ (wit) : p(stmt, wit) = 1 \}$\luiscom{Original version had "P" in this expression, instead of "p", but hereafter there was only "p".}

$wit$ is the secret witness, $p$ is a predicate, sometimes also called statement

$pp \leftarrow  \textmd{Setup}(I, p)$\\
$\pi \leftarrow \textmd{Prove}(pp, wit, stmt)$\\
$\{0, 1\} \leftarrow \textmd{Verify} (pp, \pi, stmt)$

Example: zcash-like asset
Public State: merkle tree of notes\\
Note: commitment \{Nullifier, Pubkey, assetId\}

ZK \{(pubkey, pubkeyOut, merkleProof, NullifierOut, assetId, sig)\}

The state transition is in the zkSNARK. It also checks that the transition was valid.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementation --- Sean Bowe}
\label{sec:zcon0:session1-overview:implem}

\begin{itemize}[label={- }]
\item Middle boundary between apps and security
	\begin{itemize}[label={- }]
		\item Security $\rightarrow$ good way to test / benchmark proving systems
		\item In itself
		\item Apps $\rightarrow$ ensure can use zk as black box by defining APIs
		\item Two kinds of API
				\begin{itemize}[label={- }]
				\item Non-universal (specific to R1CS) - setup, parameter format, prover (takes in instance and witness), verification
				\item Universal API for any general language / constraint system
				\end{itemize}
		\item File formats such as field properties, constraints
		\item Benchmarks (what kind of explanations / descriptions need to be given when
		making statements about the benchmark of their system. Also what other
		specifications) - degrees of freedom
				\begin{itemize}[label={- }]
					\item Here is a constraint system check it
					\item Prove a merkle tree with 128 bit security
				\end{itemize}
		\item Trusting the tech by ensuring some aspects (CRS, etc.)
		\end{itemize}
\end{itemize}


\paragraph{Specifications:}

\begin{itemize}[label={- }]
\item File formats for the constraint systems and metadata.
\item Field properties
\item Constraints (
\item Discussion of the layer of metadata like
			\begin{itemize}[label={- }]
			\item variable names
			\end{itemize}
\end{itemize}


\paragraph{Benchmarks:}
\begin{itemize}[label={- }]
\item security level
\item criteria on how they should grade their system
\end{itemize}
constraints system or merkle tree xxxx? (choose your hash function)


\paragraph{Correctness and trust:}
\begin{itemize}[label={- }]
\item generic list: air gaps, option for contributing….
\end{itemize}


Consensus in the group where if a cryptographic construct secures a lot of money, there is a lot
more trust over time. Non consensus on if having multiple bodies check a design would help.
There is nothing checking a theory against the real world.


Zcash is good use case for zero knowledge proof, because all the information comes from the
blockchain. In the real world, it's much harder, because the oracle problem becomes worse.
They are problems that arise from the composition of secure primitive.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session 2: Trust and Security}
\label{sec:zcon0:session2-trust-and-security}

We want to focus on different topics concerning the trust of ZKP schemes and applications.
These include, among others, the following list. We have generated some questions to guide the conversation.
\loosen

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textbf{Session moderator:} Daniel Benarroch, Muthu Venkitasubramaniam


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Poll the audience:} \underline{why do you (not) trust Zero-Knowledge Proof based systems?}

Guide the discussion to acknowledge all of the following, and try to map lay perspective and mist
\begin{itemize}[label={- }]
\item Cryptographic definitions (completeness, soundness, zero knowledge):
				\begin{itemize}[label={- }]
			\item How to explain the technical definitions to a non-technical person?
			\item How to convince someone that the ZKP scheme meets the definitions?
			\item How to explain and convince non-technical people that the security of the
						scheme relies on some assumption (also how to argue about those
						assumptions?)
			\item Example of caveats:
					\begin{itemize}[label={- }]
					\item Knowledge vs Argument - the difference between “there is a witness” and
								“I know a witness” can be subtle, need to have further assurance than the
								scheme itself
					\item Extractability of witness as part of the condition for catching a cheater
					\end{itemize}
			\end{itemize}

\item Key generation / trapdoor prevention:
		\begin{itemize}[label={- }]
		\item Use of trusted setup for prevention of CRS subversion
		\item How do you trust that no trapdoor exists?
		\end{itemize}

\item Protocol caveats:
		\begin{itemize}[label={- }]
				\item Defining and proving high-level domain-specific security properties
				\item Common pitfall: provenance of data
						\begin{itemize}[label={- }]
						\item Protocol must assure through some public verification all issues regarding
						data origination.
						\item Must create trust that the inputs / private data are not spoofed or faked.
						\item Example: proving properties of biometric data without being assured of
						the provenance
						\end{itemize}
				\item Legal context
						\begin{itemize}[label={- }]
							\item How does the security definitions of the scheme delegate decisions / trust
										in the legal or economic context
							\item Reliance of protocol on support of the legal system as a fallback
										mechanism (e.g., commitments as assurance of data provenance) and to
										recognize protocol outputs as legally binding (e.g., if the robbers hows a
										ZKP proof that they hold my coins, who legally owns them?)
						\end{itemize}
		\end{itemize}

\item Trust in the provider of technology
		\begin{itemize}[label={- }]
		\item How does a company prove it knows what it is doing without giving out the code?
		Not as simple as “use my software” since security requirements are hidden within
		the protocol design.
		\item If we give the client the code, what can they do? Bounded rationality, limited
		expertise, possibility of backdoors.
		\end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{More Notes}

\begin{itemize}[label={- }]
\item In general the question lies in a continuous spectrum between a very technical person
who would trust it by his / her own judgement by understanding the construction /
security to the other end where someone who does not have the ability to understand
believes it is magic and adopts it because technical people trust it
\item There is a chain of trust from theoretician to implementer / provider of tech
\item Outside the scheme, at protocol level
		\begin{itemize}[label={- }]
		\item Technology provider
		\item Legal environment / support
		\item Visualization and analogies (waldo, sudoku, etc…)
		\item User interface
		\item Protocol UC composability or ensuring caveats (inputs etc..)
		\item Bug bounties
		\item More applications and adoption incentivizes the consumer / public to trust
		\end{itemize}
\item Inside the scheme, ZKP
		\begin{itemize}[label={- }]
		\item Definitions
		\item Assumptions
		\item Peer review
		\item Key generation
		\end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session 3: Front-ends}
\label{sec:zcon0:session3-front-ends}

\textbf{Panel participants:} Sean Bowe, Izaak Meckler, Thibaut Schaeffer, Eran Tromer

\textbf{Moderator:} Nicola Greco


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Questions}

\begin{itemize}[label={- }]
\item Can you share an example from your experience of an unexpected decision or change
of mind you had when designing your respective front end?

\item Can you share examples of feedback you have received from users writing applications
in Snarky/libsnark/Bellman/ZoKrates? What is good or needs improvement?

\item What level of abstraction makes sense for export/import interoperability between Frontend languages?

\item What would you recommend to newcomers who want to contribute, equal reading in PL
and in crypto? Or, what frontend approaches/paradigms do you think are promising but
haven't yet been explored?

\item There are many other frontend projects that seem somehow less well popularized, e.g. Buffet, Geppetto. 
	I'm not sure yet how to form a productive question out of this, but i would like to acknowledge this even broader space. 
	In a later iteration of the zkproof workshop, we plan to systematically survey front-ends (but this panel is not expected to be a survey)
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{More Notes}
\begin{itemize}[label={- }]
\item Many different libraries --- have 4 / 5 different wrong ways to implement snark systems
\item Setup list of mistakes / api flaws and design based on same gadget interface
\item Merge three components for witnessing variables in libsnark
\item Circuit adaptability by non-determinism and conditional programming
\item Forced to import libsnark into more native wrapper
\item Good that there are many different implementations
\item Witness generation cannot separated from constraint generation since one can screw things up
\item Where do we see the implementations going? Converging or not?
			\begin{itemize}[label={- }]
			\item Gadgets vs other kind of structures / terminology
			\item Converge towards one API?
			\item Defining usability well
			\item Interoperability between many front-ends to back-ends.
			\end{itemize}
\end{itemize}