\section{Efficiency}
\label{security:Efficiency}
 
A specification of a proof system may include claims about efficiency and if it does the units of measurement MUST be clearly stated. Relevant metrics may include:

\begin{bulletize}
    \item \textbf{Round complexity:} Number of transmissions between prover and verifier. Usually measured in the number of moves, where a move is a message from one party to the other.
An important special case is that of 1-move proof systems, aka non-interactive proof systems, where the verifier receives a proof from the prover and directly decides whether to accept or not. Non-interactive proofs may be transferable, i.e., they can be copied, forwarded and used to convince several verifiers.
    \item \textbf{Communication:} Total size of communication between prover and verifier. Usually measured in bits.
    \item \textbf{Prover computation:} Computational effort the prover expends over the duration of the protocol. Sometimes measured as a count of the dominant cryptographic operations (to avoid system dependence) and sometimes measured in seconds on a particular system (when making concrete measurements).
    \item Depending on the intended usage, many other metrics may be important: memory consumption, energy consumption, entropy consumption, potential for parallelisation to reduce time, and offline/online computation trade-offs.
    \item \textbf{Verifier computation:} Computational effort the verifier expends over the duration of the protocol.
    \item Setup \textbf{cost:} Size of setup parameters, e.g. a common reference string, and computational cost of creating the setup.
\end{bulletize} 

Readers of a proof system specification may differ in the granularity they need in the efficiency measurements. Take as an example a proof system consisting of an information theoretic core that is then compiled with cryptographic primitives to yield the full system. An implementer will likely want to have a detailed performance analysis of the information theoretic core as well as the cryptographic compilation, since this will guide her choice of trade-offs and optimizations. A consumer on the other hand will likely want to have a high-level performance analysis and an apples-to-apples comparison to competing proof systems. We therefore recommend to provide both a detailed analysis that quantifies all the dominant efficiency costs, and a bottom-line analysis that summarizes performance for reasonable choices of parameters and identifies the optimal performance region.
\loosen



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\tmpTitle{Characterization of security properties}
\subsection[\tmpTitle]{\tmpTitle\revblock[rev:comp-sec-par:bench:characterize-properties]{\ref{it:comp-sec-par:bench:characterize-properties}}}
\label{security:efficiency:characterize-properties}
	The benchmarking of a technique should clarify the distinct security levels achieved/conjectured for different security properties, e.g., soundness vs.\ zero-knowledge.
	In each case, the security type should also be clarified with respect to being unconditional, statistical or computational.
	When considering computational security, it should be clarified to what extent pre-computations may affect the security level, and whether/how known attacks may be parallelizable.
	All security claims/assertions should be qualified clearly with respect to whether they are based on proven security reductions or on heuristic conjectures. 
    In either case the security analysis should make clear which computational assumptions and implementation requirements are needed. 
    It should be made explicit whether (and how) the security levels relate to classical or quantum adversaries. 
    When applicable, the benchmarking should characterize the security (including possible unsuitability) of the technique against quantum adversaries.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\tmpTitle{Computational security levels for benchmarking}
\subsection[\tmpTitle]{\tmpTitle\revblock[rev:comp-sec-par:bench:security-levels]{\ref{it:comp-sec-par:bench:security-levels}}}
\label{security:efficiency:comp-sec-levels}

	The benchmarks for each technique \shall\ include at least one parameterization 
for achieving a conjectured computational security level $\kappa$ approximately equal to, or greater than, 128 bits.
	Each technique \should\ also be benchmarked for at least one 
additional higher computational security level, such as 192 or 256 bits.
    (If only one, the latter is preferred.)
    The benchmarking at more than one level aids with the understanding of how
the efficiency varies with the security level.
    The interest in a security level as high as 256 bits can be considered a 
precautious (and heuristic) safety margin, compared for example with intended 128 bits.
    This is intended to handle the possibility that the conjectured level of security is later found to have been over-estimated.
	The evaluation at computational security below 128 bits may be justified for the purpose 
of clarifying how the execution complexity or time varies with the security parameter, 
but should not be construed as a recommendation for practical security.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{An exception allowing lower computational security parameter.}\revblock[rev:comp-sec:exception-lower-levels]{\ref{it:sec-par:exception-lower-levels}}
	With utmost care, a computational security level may be justified below 128 bits,
including for benchmarking.
	The following text describes as exception.
	In some interactive ZKPs (see Section 2.2), there may be cryptographic properties that only need to be held during a portion of a protocol execution, which in turn may be required to take less than a fixed amount of time, say, one minute.
	For example, a commitment scheme used to enable temporary hiding during a 
coin-flipping protocol may only need to hold until the other party reveals a secret value.
	In such case the property may be implemented with less than 128 bits of security, 
under special care (namely with respect to composition in a concurrent setting)
and if the difference in efficiency is substantial.
	Such decreased security level of a component of a protocol may also be 
useful for example to enable properties of deniability (non-transferability).

    Depending on the application, other exceptions may be acceptable, upon careful analysis, when the witness whose knowledge is being proven is itself discoverable from the ZK instance with less computational resources than those corresponding to 128 bits of security. 














%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{List of references:}\pdfbookmark[1]{List of references}{pdfbkm:security:list-refs}
\cite{2013:tcc:snargs-via-LIPs},
\cite{2016:tcc:IOPs},
\cite{2017:eurocrypt:lattice-based-snargs},
\cite{2016:eurocrypt:efficient-zk-args-for-arithmetic},
\cite{2017:asiacrypt:linear-time-zkps-for-arithmetic},
\cite{2018:asiacrypt:arya-nearly-lineat-time-zkps-for-correct},
\cite{1998:crypto:zkps-for-finite-field-arithmetic},
\cite{2013:QSPs-and-succinct-NIZKs-without-PCPs},
\cite{2015:JACM:delegating-computation-interactive-proofs-for-muggles},
\cite{2010:asiacrypt:short-NIZKPs},
\cite{2018:SP:Doubly-efficient-zkSNARKs-without-trusted-setup},
\cite{2007:stoc:ZK-from-SMPC},
\cite{2012:tcc:On-Efficient-ZK-PCPs},
\cite{1995:crypto:Improved-Efficient-Arguments},
\cite{2008:icalp:interactive-PCP},
\cite{2017:ccs:ligero},
\cite{2000:SIAM:Computationally-Sound-Proofs},
\cite{2016:stoc:Constant-round-Interactive-Proofs-for-Delegating-Computation},
\cite{2018:SP:vRAM},
\cite{2017:SP:vSQL},
\cite{2016:Sec:ZKBoo}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{References:}
%\label{security:references}

%%%%%	\begin{itemize}
%%%%%    \item{} [BCIOP] Bitansky, N., Chiesa, A., Ishai, Y., Ostrovsky, R. \& Paneth, O. "Succinct non-interactive arguments via linear interactive proofs." TCC (2013).
%%%%%    \item{} [BCS16] Ben-Sasson, E., Chiesa, A., \& Spooner, N. "Interactive oracle proofs." TCC (2016).
%%%%%    \item{} [BISW17] Boneh, D., Ishai, Y., Sahai, A., \& Wu, D. J. “Lattice-based snargs and their application to more efficient obfuscation.” Eurocrypt (2017).
%%%%%    \item{} [Bootle16] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., \& Petit, C. “Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting.” Eurocrypt (2016).
%%%%%    \item{} [Bootle17] Bootle, J., Cerulli, A., Ghadafi, E., Groth, J., Hajiabadi, M., \& Jakobsen, S. K. “Linear-time zero-knowledge proofs for arithmetic circuit satisfiability.” Asiacrypt (2017).
%%%%%    \item{} [Bootle18] Bootle, J., Cerulli, A., Groth, J., Jakobsen, S., \& Maller, M. “Nearly Linear-Time Zero-Knowledge Proofs for Correct Program Execution” ePrint 2018/380 (2018).
%%%%%    \item{} [Cramer-Damgård] Cramer, R., \& Damgård, I. “Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free?.” CRYPTO (1998).
%%%%%    \item{} [GGPR] Gennaro, R., Gentry, C., Parno, B., \& Raykova, M. “Quadratic span programs and succinct NIZKs without PCPs.” Eurocrypt (2013).
%%%%%    \item{} [GKW] Goldwasser, S., Kalai, Y. T., \& Rothblum, G. N. “Delegating computation: interactive proofs for muggles.” STOC (2008).
%%%%%    \item{} [Groth10] Groth, J.”Short Non-interactive Zero-Knowledge Proofs.” ASIACRYPT (2010)
%%%%%    \item{} [Hyrax] Wahby, R. S., Tzialla, I., Thaler, J., \& Walfish, M. “Doubly-efficient zkSNARKs without trusted setup.” IEEE Security and Privacy (2018).
%%%%%    \item{} [IKOS] Ishai, Y., Kushilevitz, E., Ostrovsky, R., \& Sahai, A. “Zero-knowledge from secure multiparty computation.” STOC (2007).
%%%%%    \item{} [IMS] Ishai, Y., Mahmoody, M., \& Sahai, A. “On Efficient Zero-Knowledge PCPs.” TCC (2012)
%%%%%    \item{} [Kilian] Kilian, J. “Improved efficient arguments.” CRYPTO (1995).
%%%%%    \item{} [KR08] Kalai, Y. T., \& Raz, R. “Interactive PCP.” ICALP (2008).
%%%%%    \item{} [Ligero] Ames, S., Hazay, C., Ishai, Y., \& Venkitasubramaniam, M. “Ligero: Lightweight sublinear arguments without a trusted setup.” CCS (2017).
%%%%%    \item{} [Micali] Micali, S. "Computationally sound proofs." SIAM Journal on Computing (2000).
%%%%%    \item{} [RRR] Reingold, O., Rothblum, G. N., \& Rothblum, R. D. “Constant-round interactive proofs for delegating computation.” STOC (2016).
%%%%%    \item{} [vRAM] Zhang, Y., Katz, J., Papadopoulos, D., \& Papamanthou, C. “vRAM: Faster Verifiable RAM With Program-Independent Preprocessing.” IEEE Security and Privacy (2018).
%%%%%    \item{} [vSQL] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., \& Papamanthou, C. “vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases.” IEEE Security and Privacy (2017).
%%%%%	\end{itemize}



