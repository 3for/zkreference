\chapter{Applications track}
\label{chap:track-apps}

\vspace{2em}
\textbf{Original title:} ZKProof Standards Applications Track Proceedings

\textbf{Date:} 1 August 2018 + subsequent revisions

{\itshape\centering
{\color{ongoingred} This document is an ongoing work in progress.}\\
{\color{ongoingred} Feedback and contributions are encouraged.}\\
}

\vspace{1em}
\textbf{Track chairs:} 
Daniel Benarroch, Ran Canetti and Andrew Miller

\textbf{Track participants:} 
Shashank Agrawal, Tony Arcieri, Vipin Bharathan, Josh Cincinnati, Joshua Daniel,  Anuj Das Gupta, Angelo De Caro, Michael Dixon, Maria Dubovitskaya, Nathan George, Brett Hemenway Falk, Hugo Krawczyk, Jason Law, Anna Lysyanskaya, Zaki Manian, Eduardo Morais, Neha Narula, Gavin Pacini, Jonathan Rouach, Kartheek Solipuram, Mayank Varia, Douglas Wikstrom and Aviv Zohar 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Motivation}
\label{apps:intro}
 
In this track we aim to overview existing techniques for building ZKP based systems, including designing the protocols to meet the best-practice security requirements. One can distinguish between high-level and low-level applications, where the former are the protocols designed for specific use-cases and the latter are the underlying operations needed to define a ZK predicate. We call gadgets the sub-circuits used to build the actual constraint system needed for a use-case. In some cases, a gadget can be interpreted as a security requirement (e.g.: using the commitment verification gadget is equivalent to ensuring the privacy of underlying data). 

As we will see, the protocols can be abstracted and generalized to admit several use-cases; similarly, there exist compilers that will generate the necessary gadgets from commonly used programming languages. Creating the constraint systems is a fundamental part of the applications of ZKP, which is the reason why there is a large variety of front-ends available.

In this document, we present three use-cases and a set of useful gadgets to be used within the predicate of each of the three use-cases: identity framework, asset transfer and regulation compliance.\pdfcomment[author={Eran Tromer}]{Missing coverage of recursive composition and Proof-Carrying Data as an important high-level tool (in existing prototypes and emerging real applications).
There's a couple of brief mentions in the Implementation track, but those don't cover the usefulness in applications.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{What this document is NOT about:}
\begin{itemize}
 \item A unique explanation of how to build ZKP applications
 \item An exhaustive list of the security requirements needed to build a ZKP system
 \item A comparison of front-end tools
 \item A show of preference for some use-cases or others
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notation and Definitions}
\label{apps:notation-defs}

See \hyperref[chap:track-security]{Security} and \hyperref[chap:track-implem]{Implementation} tracks for definitions of predicate / prover / verifier / proof / proving key, etc.

When designing ZK based applications, one needs to keep in mind which of the following three models (that define the functionality of the ZKP) is needed:
\begin{enumerate}
    \item Publicly verifiable as a requirement: a scheme / use-case where the proofs are transferable, where such property is actually a requirement of the system. Only non-interactive ZK (NIZK) can actually hold this property.\luiscom{Consider revising this assertion, since if transferability is a design goal, it can still be obtained with an interactive protocol.}
    \item Designated verifier as a security feature: only the intended receiver of the proof can verify it, making the proof non-transferable.This property can apply to both interactive and non-interactive ZK.
    \item The final model is one where neither of the above is needed: a ZK where there is no need to be able to transfer but also no non-transferability requirement. Again, this model can apply both in the interactive and non-interactive model.
\end{enumerate}

For example, digital money based applications belong to the first model,\luiscom{Unclear why. Seems reasonable to devise use-cases where one wants to perform a non-transferable ZKP about something that happened with digital money.} compliance for regulation lives in the second model (albeit depending on the use-case). In general, the credential system can be in both of the last two models, given the extra constraints that would make it belong to the second model.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Previous works}
\label{apps:previous-works}

This section will include an overview of some of the works and applications existing in the zero-knowledge world. 
We asked the Applications track participants to send us a description of their work.\luissug{Consider formatting all explicitly-temporary text with another color.}
We are now in the process of collecting the content.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gadgets within predicates}
\label{apps:gadgets-within-predicates}


Formalizing the security of these protocols is a very difficult task, especially since there is no predetermined set of requirements, making it an ad-hoc process. 
Here we outline a set of initial gadgets to be taken into account.%
\luised{Created one table containing only the gadget names and the description in English; then included one table for each gadget. 
This enables shorter tables, not breaking the page, and allows easier indexing of each gadget (e.g., now showing in the initial List of Tables).} 
See \reftab{tab:list-gadgets} for a simple list of gadgets --- this list should be expanded continuously and on a case by case basis.
	For each of the gadgets %below, 
we write the following representations, specifying what is the secret / witness, what is public / statement:

NP statements for non-technical people:

\hspace{.08\textwidth}\begin{minipage}{.92\textwidth}\bfseries
		For the [public] chess board configurations $A$ and $B$;\newline
		I know some [secret] sequence $S$ of chess moves;\newline
		such that when starting from configuration $A$, and applying $S$, all moves are legal and the final configuration is $B$.
		\end{minipage}\luissug{This is a nice example that does not require whose instance does not require commitments or encryption --- consider perhaps adding it to \reftab{tab:basic-examples-what-is-a-ZK}, depending on how the documentation wants to position ZKPs of language vs. ZKPoKs.
		}~~~\luiscom{(Another chess-related example can be formed from the ``eight queens puzzle''. A party wants to prove that it knows a chess-table configuration with 8 queens, such that no queen is attacking any other.\textCR This is not a suggestion for inclusion in the text, but just a note to recall to check how the distinct definitions/notations of ZKP of membership vs. ZKP of knowledge cover different examples.}

General form (Camenisch-Stadler): \textbf{Zk \{ ( wit):   P(wit, statement)  \}}

Example of ring signature: \textbf{Zk \{ (sig):  VerifySignature(P1, sig) or VerifySignature(P2, sig)  \}}



\newcounter{cntGadget}\setcounter{cntGadget}{0}
\renewcommand{\thecntGadget}{G\arabic{cntGadget}}
\newcommand{\newGadget}[1][]{\refstepcounter{cntGadget}\protect\ifthenelse{\equal{#1}{}}{}{\label{#1}}\thecntGadget}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\mytablecap[tab:list-of-gadgets]{List of gadgets}
\begin{table}[H]
\mytabcap{List of gadgets}{List of gadgets}\label{tab:list-gadgets}
\begin{center}
\begin{edtable}{tabular}{|>{\begmin{.04}\centering}c<{\myendmini}|>{\begmin{.23}}l<{\myendmini}||>{\begmin{.48}}l<{\myendmini}|>{\begmin{.13}\centering}c<{}|}
\hline \rowcolor{colorRowHead} \bfseries \raisebox{-3ex}{\#}
			& \centering \bfseries \raisebox{-3ex}{Gadget name}
			& \centering \bfseries English description of the initial gadget (before adding ZKP) %\subtab[l]{ \\ }
			& \centering \bfseries Table with examples \rowend
\hline 
\hline \newGadget[gad:commitment] & Commitment 
				& Envelope\luiscom{``Commitment'' is traditionally equated to a ``sealed envelop'' ... but a ``vault'' would have the additional feature of requiring a secret key for the opening phase. (Reflect on the best way to convey intuition to a non-cryptographer.) One can actually implement a commitment by sending a vault by mail ... and later the key} & \reftab{tab:gadget-commitment-envelope} \rowend
\hline \newGadget[gad:signatures] & Signatures 
				& \subtab{\fillindesc\\\red{(inc. blind, ring, \red{homom}?)}} & \reftab{tab:gadget-signature} \rowend
\hline \newGadget[gad:encryption] & Encryption 
				& Envelope with a receiver stamp & \reftab{tab:gadget-encryption} \rowend
\hline \newGadget[gad:dist-decryption] & Distributed decryption 
				& Envelope with a receiver stamp that requires multiple people to open & \reftab{tab:gadget-dist-decryption} \rowend
\hline \newGadget[gad:rand-func] & Random function 
				& Lottery machine & \reftab{tab:gadget-random-function} \rowend
\hline \newGadget[gad:set-membership] & Set membership 
				& \fillindesc & \reftab{tab:gadget-set-membership} \rowend
\hline \newGadget[gad:mix-net] & Mix-net 
				& Ballot box & \reftab{tab:gadget-mix-net} \rowend
\hline \newGadget[gad:gen-calculations] & Generic circuits, TMs, or RAM programs 
				& General calculations & \reftab{tab:gadget-general-computation} \rowend
\hline
\end{edtable}\vspace{1em}
\end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\headerRowForGadgets}{\rowcolor{colorRowHead}Enhanced gadget (after adding ZKP) 
		& ZKP statement (in a PoK notation) 
		& Prover knows a witness ...
		& ...for the public instance ...
		& ...s.t. the following predicate holds
		& Technical notation (API) \rowend}

%the six arguments are factors for the width of the 6 columns
\newenvironment{gadgettabular}[6]{\begin{center}\footnotesize\begin{edtable}{tabular}{|>{\begmin{#1}}l<{\myendmini}|>{\begmin{#2}}l<{\myendmini}|>{\begmin{#3}}l<{\myendmini}|>{\begmin{#4}}l<{\myendmini}|>{\begmin{#5}}l<{\myendmini}|>{\begmin{#6}}c|}\hline \headerRowForGadgets \hline}{\end{edtable}\vspace{1em}\end{center}}

%\newenvironment{gadgettabular}{\begin{center}\footnotesize\begin{edtable}{tabular}{|*{5}{>{\begmin{.21}}l<{\myendmini}|}>{\begmin{.1}}c|}\hline \headerRowForGadgets \hline}{\end{edtable}\vspace{1em}\end{center}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\afterpage{%
    \clearpage% 
    \begin{landscape} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[H]
\mytabcap{Commitment gadget}{Commitment gadget (\ref{gad:commitment}; envelope)\luiscom{Would it be better to include these tables in landscape-oriented pages?\textCR Should each row have its own index, e.g., G1a, G1b, G1c, G1d?}}
\label{tab:gadget-commitment-envelope}
\begin{gadgettabular}{.21}{.21}{.21}{.21}{.21}{.1}
			I know the value hidden inside this envelope, even though I cannot change it
		& Knowledge of committed value(s) (openings)
    & Opening(s) $O = (v,r)$ containing a value and randomness
    & Committed value(s) $C$
    & $C = Comm(O)$, component-wise if there are multiple $C, O$
    & \rowend
\hline 
		  I know that the value hidden inside these two envelopes are equal
    & Equality of committed values
    & Opening $O$
    & Committed values $C_1$ and $C_2$
    & $C_1 = Comm(O)$ and $C_2 = Comm(O)$
    & \rowend
\hline
		  I know that the values hidden inside these two envelopes are related in a specific way
    & Relationships between committed values -- logical, arithmetic, etc.
		& Witnesses $O_1$ and $O_2$
		& Committed values $C_1$ and $C_2$, relation $R$
		& $C_1 = Comm(O_1)$, $C_2 = Comm(O_2)$, and $R(O_1, O'_2) = \texttt{True}$
		& \rowend
\hline
      The value inside this envelope is within a particular range
		& Range proofs
		& Opening $O$
		& Committed value $C$, interval $I$
		& $C = Comm(O)$ and $O$ is in the range $I$
		& \rowend
\hline
\end{gadgettabular}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[H]
\mytabcap{Signature gadget}{Signature gadget (\ref{gad:signatures}; \fillindesc)}\label{tab:gadget-signature}
\begin{gadgettabular}{.21}{.21}{.21}{.21}{.21}{.1}
			\fillindesc 
		& Knowledge of a signature on a message\luissug{Consider differentiating more explicitly the secret vs.\ public info. For example: ``Knowledge of a secret signature of a public message'' or ``Knowledge of a secret signature of a commonly known message''}
    & Signature $\sigma$
    & Verification key $VK$, message $M$
    & Verify$(VK, m, \sigma) = \tt True$
    & \rowend
\hline 
		  \textbf{\red{propose: blind, ring, group, homom.}}\luistodo{Unclear in the original document if this row is to be within the signature gadget. I just assumed yes, as in blind signature, ring signature, ...}
		& Knowledge of a signature on a committed value\luissug{Consider differentiating more explicitly the secret vs.\ public info. For example: ``Knowledge of a secret signature on a publicized commitment of a known secret message [and knowledge of its opening]'' (maybe the suggestion fails by stretching the sentence too much, but the current statement seems somewhat dubious about what is secret.)}
		& Message $M$\luissug{It appears that an opening O should also be included here. An alternative (more contrived) scenario is the prover only knowing a transferable NIZK that C is a correct commitment of M, and proving possessing such NIZK :-) ...}, signature $\sigma$
		& Verification key $VK$, committed value $C$
		& $C = Comm(M)$ and Verify$(VK, m, \sigma) = \tt True$
    & \rowend
\hline
\end{gadgettabular}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[H]
\mytabcap{Encryption gadget}{Encryption gadget (\ref{gad:encryption}; envelope with a receiver stamp)}\label{tab:gadget-encryption}
\begin{gadgettabular}{.21}{.21}{.21}{.21}{.21}{.1}
			\fillindesc 
		& Knowledge of a signature on a message
    & Signature $\sigma$
    & Verification key $VK$, message $M$
    & Verify$(VK, m, \sigma) = \tt True$
    & \rowend
\hline
\end{gadgettabular}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[H]
\mytabcap{Distributed-decryption gadget}{Distributed-decryption gadget (\ref{gad:dist-decryption}; envelope with a receiver stamp that requires multiple people to open)}\label{tab:gadget-dist-decryption}
\begin{gadgettabular}{.21}{.21}{.21}{.21}{.21}{.1}
			The output plaintext(s) correspond to the public ciphertext(s).
     & Knowledge of the plaintext
     & Secret shares of the decryption key
     & Ciphertext(s) $C$ and Encryption key $PK$
     & $Dec(SK, C) = P$, component-wise if $\exists$ multiple $C$
     & \rowend
\hline
\end{gadgettabular}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[H]
\mytabcap{Random-function gadget}{Random-function gadget (\ref{gad:rand-func}; lottery machine)}\label{tab:gadget-random-function}
\begin{gadgettabular}{.21}{.21}{.21}{.21}{.21}{.1}
			Verifiable random function (VRF)
     & VRF was computed correctly from a secret seed and a public (or secret) input
     & Secret seed $W$
     & Input $X$, Output $Y$
     & $Y = VRF(W, X)$
     & \rowend
\hline
\end{gadgettabular}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[H]
\mytabcap{Set-membership gadget}{Set-membership gadget (\ref{gad:set-membership}; \fillindesc)}\label{tab:gadget-set-membership}
\vspace{-.4em} %adjustment \vspace to revise ... temporarily here to enable 3 tables to fit within 1 page
\begin{gadgettabular}{.21}{.21}{.21}{.21}{.21}{.1}
			Accumulator
     & Set inclusion
		 & \fillindesc 
		 & \fillindesc 
		 & \fillindesc 
		 & \rowend
\hline
			 \fillindesc 
     & Set non-inclusion
		 & \fillindesc 
		 & \fillindesc 
		 & \fillindesc 
		 & \rowend
\hline
\end{gadgettabular}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-1.5em} %adjustment \vspace to revise ... temporarily here to enable 3 tables to fit within 1 page
\begin{table}[H]
\mytabcap{Mix-net gadget}{Mix-net gadget (\ref{gad:mix-net}; ballot box)}\label{tab:gadget-mix-net}
\vspace{-.4em} %adjustment \vspace to revise ... temporarily here to enable 3 tables to fit within 1 page
\begin{gadgettabular}{.18}{.28}{.17}{.21}{.21}{.1}
			 Shuffle
     & The set of plaintexts in the input and the output ciphertexts respectively are identical.
     & Permutation $\pi$, Decryption key $SK$
     & Input ciphertext list $C$ and Output ciphertext list $C'$
     & $\forall j, Dec(SK, \pi(C_j)) = Dec(SK, C'_j)$
     & \rowend
\hline
		   Shuffle and reveal
		 & The set of plaintexts in the input ciphertexts is identical to the set of plaintexts in the output.
		 & Permutation $\pi$, Decryption key $SK$
		 & Input ciphertext list C and Output plaintext list $P$
		 & $\forall j, Dec(SK, \pi(C_j)) = P_j$
		 & \rowend
\hline
\end{gadgettabular}
\end{table}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-1.5em} %adjustment \vspace to revise ... temporarily here to enable 3 tables to fit within 1 page
\begin{table}[H]
\mytabcap{Generic-computation gadget}{Generic circuits, TMs, or RAM programs\luissug{Find a more concise name to identify the type of gadget} gadgets (\ref{gad:gen-calculations}; general calculations)}\label{tab:gadget-general-computation}
\vspace{-.4em} %adjustment \vspace to revise ... temporarily here to enable 3 tables to fit within 1 page
\begin{gadgettabular}{.21}{.26}{.14}{.28}{.16}{.1}
			 There exists some secret input that makes this calculation correct
     & ZK proof of correctness of circuit/Turing machine/RAM program computation
     & Secret input w
     & Program $C$ (either a circuit, TM, or RAM program), public input $x$, output $y$
     & $C(x, w) = y$
     & \rowend
\hline
		   This calculation is correct, given that I already know that some sub-calculation is correct
		 & ZK proof of verification + postprocessing of another output (Composition)
		 & Secret input $w$
		 & Program $C$ with subroutine $C'$, public input $x$, output $y$, intermediate value $z = C'(x, w)$, zk proof $\pi$ that $z = C'(x, w)$
		 & $C(x, w) = y$
		 & \rowend
\hline
\end{gadgettabular}
\end{table}


\end{landscape} 
} %end of \afterpage
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Identity framework}
\label{apps:id-framework}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Overview}

%\setlength{\parindent}{2em}
%\setlength{\parskip}{0pt}

In this section we describe identity management solutions using zero knowledge proofs. The idea is that some user has a set of attributes that will be attested to by an issuer or multiple issuers, such that these attestations correspond to a validation of those attributes or a subset of them. 


After attestation it is possible to use this information, hereby called a credential, to generate a claim about those attributes. Namely, consider the case where Alice wants to show that she is over 18 and lives in a country that belongs to the European Union. If two issuers were responsible for the attestation of Alice`s age and residence country, then we have that Alice could use zero knowledge proofs in order to show that she possesses those attributes, for instance she can use zero knowledge range proofs to show that her age is over 18, and zero knowledge set membership to prove that she lives in a country that belongs to the European Union. This proof can be presented to a Verifier that must validate such proof to authorize Alice to use some service. Hence there are three parties involved: (i) the credential holder; (ii) the credential issuer; (iii) and the verifier.  


We are going to focus our description on a specific use case: accredited investors. In this scenario the credential holder will be able to show that she is accredited without revealing more information than necessary to prove such a claim.   


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Motivation for Identity and Zero Knowledge}

Digital identity has been a problem of interest to both academics and industry practitioners since the creation of the internet. Specifically, it is the problem of allowing an individual, a company, or an asset to be identified online without having to generate a physical identification for it, such as an ID card, a signed document, a license, etc. Digitizing Identity comes with some unique risks, loss of privacy and consequent exposure to Identity theft, surveillance, social engineering and other damaging efforts. Indeed, this is something that has been solved partially, with the help of cryptographic tools to achieve moderate privacy (password encryption, public key certificates, internet protocols like TLS\luiscom{Add citation. Capitalized it.} and several others). Yet, these solutions are sometimes not enough to meet the privacy needs to the users / identities online. Cryptographic zero knowledge proofs can further enhance the ability to interact digitally and gain both privacy and the assurance of legitimacy required for the correctness of a process.
 
The following is an overview of the generalized version of the identity scheme. We define the terminology used for the data structures and the actors, elaborate on what features we include and what are the privacy assurances that we look for. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Terminology / Definitions}

In this protocol we use several different data structures to represent the information being transferred or exchanged between the parties. We have tried to generalize the definitions as much as possible, while adapting to the existing Identity standards and previous ZKP works.

\mbox{}\\
\textbf{Attribute.} The most fundamental information about a holder in the system (e.g.: age, nationality, univ. Degree, pending debt, etc.). These are the properties that are factual and from which specific authorizations can be derived.

\textbf{(Confidential and Anonymous) Credential.} The data structure that contains attribute(s) about a holder in the system (e.g.: credit card statement, marital status, age, address, etc). Since it contains private data, a credential is not shareable. 


\textbf{(Verifiable) Claim.} A zero-knowledge predicate about the attributes in a credential (or many of them). A claim must be done about an identity\luiscom{Unclear why it ``must'' be about an identity.} and should contain some form of logical statement that is included in the constraint system defined by the zk-predicate. 

\textbf{Proof of Credential.} The zero knowledge proof that is used to verify the claim attested by the credential. Given that the credential is kept confidential, the proof derived from it is presented as a way to prove the claim in question.

\mbox{}\\
\noindent The following are the different parties present in the protocol:

\textbf{Holder.} The party whose attributes will be attested to. The holder holds the credentials that contain his / her attributes and generates Zero Knowledge Proofs to prove some claim about these. We say that the holder presents a proof of credential for some claim.

\textbf{Issuer.} The party that attests attributes of holders. We say that the issuer issues a credential to the holder.

\textbf{Verifier.} The party that verifies some claim about a holder by verifying the zero knowledge proof of credential to the claim.

\mbox{}\\
\noindent\underline{Remark:} The main difference between this protocol and a non-ZK based Identity protocol is the fact that in the latter, the holder presents the credentials themselves as the proof for the claim / authorization, whereas in this protocol, the holder presents a zero knowledge proof that was computed from the credentials.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Protocol Description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Functionality.}
There are many interesting features that we considered as part of the identity protocol. 
There are four basic functionalities that we decided to include from the get go: 
\begin{itemize}
\item[(1)] third party anonymous and confidential attribute attestations through \textbf{credential issuance} by the issuer;
\item[(2)] confidentially proving claims using zero knowledge proofs through the \textbf{presentation of proof of credential} by the holder;
\item[(3)] \textbf{verification of claims} through zero knowledge proof verification by the verifier; and
\item[(4)] unlinkable \textbf{credential revocation} by the issuer. 
\end{itemize}

There are further functionalities that we find interesting and worth exploring but that we did not include in this version of the protocol. 
Some of these are credential transfer, authority delegation and trace auditability. We explain more in detail what these are and explore ways they could be instantiated. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Privacy requirements.}
One should aim for a high level of privacy for each of the actors in the system, but without compromising the correctness of the protocol. We look at anonymity properties for each of the actors, confidentiality of their interactions and data exchanges, and at the unlinkability of public data (in committed form). These usually can be instantiated as cryptographic requirements such as commitment non-malleability, indistinguishability from random data, unforgeability, accumulator soundness or as statements in zero-knowledge such as proving knowledge of preimages, proving signature verification, etc.

\begin{itemize}
		\item \underline{Holder anonymity:} the underlying physical identity\luiscom{It is unclear the actual meaning of ``physical identity''. Why does it have to be physical for the anonymity concept to apply? Consider clarifying.} of the holder must be hidden from the general public, and if needed from the issuer and verifier too. For this we use pseudo-random strings called identifiers, which are tied to a secret only known to the holder. 
		\item \underline{Issuer anonymity:} only the holder should know what issuer issued a specific credential.
		\item \underline{Anonymous credential:} when a holder presents a credential, the verifier may not know who issued the certificate. He / She may only know that the credential was issued by some approved issuer.
		\item \underline{Holder untraceability:} the holder identifiers and credentials can’t be used to track holders through time.
		\item \underline{Confidentiality:} no one but the holder and the issuer should know what the credential attributes are.
		\item \underline{Identifier linkability:} no one should be able to link two identifier unless there is a proof presented by the holder.
		\item \underline{Credential linkability:} No one should be able to link two credentials from the publicly available data. Mainly, no two issuers should be able to collude and link two credentials to one same holder by using the holder’s digital identity.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{In depth view.} 
For the specific instantiation of the scheme, we examine 
in \reftab{tab:apps:functionality-vs-privacy-requirements}\luised{Added reference to the table.}
the different ways that these requirements can be achieved and what are the trade-offs to be done (e.g.: using pairwise identifiers vs. one fixed public key; different revocation mechanisms; etc.) and elaborate on the privacy and efficiency properties of each. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% NEW TABLE

\newcommand{\begminB}[1]{\begmin{#1}\setlist[itemize]{leftmargin=1.5ex}\renewcommand{\labelitemi}{-}}
\newenvironment{funcprivtabular}[5]{\begin{center}\footnotesize\begin{longtable}{|>{\begminB{#1}}l<{\myendmini}|>{\begminB{#2}}l<{\myendmini}|>{\begminB{#3}}l<{\myendmini}|>{\begminB{#4}}l<{\myendmini}|>{\begmin{#5}}l|}\hline }{\end{longtable}\vspace{1em}\end{center}}

\afterpage{%
    \clearpage% 
\begin{landscape} 

\vspace{.5em}
\def\tmptabtitle{Functionalities vs.\ privacy and robustness requirements}
{\mytabcap{\tmptabtitle}{\tmptabtitle\luistodo{Consider breaking this into 4 tables, each with only 3 columns}}\label{tab:apps:functionality-vs-privacy-requirements}}
\vspace{-1.5em}
\begin{funcprivtabular}{.1827}{.3027}{.3027}{.3027}{.1}
\rowcolor{colorRowHead}\textbf{Functionality / Problem}
     & \textbf{Instantiation Method}
		 & \textbf{Proof Details}
		 & \textbf{Privacy / Robustness}
		 & \textbf{Reference} \rowend
%%%%%%%%%%%%
\hline
    \textbf{Holder identification:} how  to identify a holder of credentials
	& Single identifier in the federated realm: PRF based Public Key (idPK) derived from the physical ID\luiscom{What is the physical ID. Does it mean the person, some hardware (e.g., smartcard), ...?} of the entity and attested / onboarded by a federal authority 
	& \begin{itemize}
    \item The first credential an entity must get is the onboarding credential that attests to its identity on the system
		\item Any proof of credential generated by the holder must include a verification that the idPK was issued an onboarding credential
		\end{itemize}
	& \begin{itemize}
    \item Physical identity is hidden yet connected to the public key. 
    \item Issuers can collude to link different credentials by the same holder. 
    \item An entity can have only one identity in the system 
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\cline{2-5}
	& Single identifier in the self-sovereign realm: PRF based Public Key (idPK) self derived by the entity.
	& \begin{itemize}	
    \item Any proof of credential must show the holder knows the preimage of the idPK and that the credential was issued to the idPK in question
		\end{itemize}
	& \begin{itemize}	
		\item Physical identity is hidden and does not necessarily have to be connected to the public key
		\item Issuers can collude to link different credentials by the same holder
		\item An entity can have several identities and conveniently forget any of them upon issuance of a “negative credential”
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\cline{2-5}
	& Multiple identifiers: Pairwise identification through identifiers. For each new interaction the holder generates a new identifier. 
  & \begin{itemize}	
		\item Every time a holder needs to connect to a previous issuer, it must prove a connection of the new and old identifiers in ZK
    \item Any proof of credential must show the holder knows the secret of the identifier that the credential was issued to.
		\end{itemize}	 
	& \begin{itemize}	 
		\item Physical identity is hidden and does not necessarily have to be connected to the public key
    \item Issuers cannot collude to\luiscom{Editorial: issuers can always collude; the question is what capabilities they can gain therefrom. Consider: "A set of colluding issuers cannot ..."} link the credentials by the same holder
    \item An entity can have several identities and conveniently forget any of them upon issuance of a “negative credential”\luiscom{Consider clarifying the meaning of negative credential.}
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\hline
	  \textbf{Issuer identification}
	& Federated permissions: there is a list of approved issuers that can be updated by either a central authority or a set of nodes
	& \begin{itemize}
    \item To accept a credential one must validate the signature against one from the list. To maintain the anonymity of the issuer, ring signatures can be used
    \item For every proof of credential, a holder must prove that the signature in its credential is of an issuer in the approved list
		\end{itemize}
	& \begin{itemize}
    \item The verifier / public would not know who the issuer of the credential is but would know it is approved.
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\cline{2-5}
	& Free permissions: anyone can become an issuer, which use identifiers:
		\begin{itemize}
    \item Public identifier: type 1 is the issuer whose signature verification key is publicly available
    \item Pair-wise identifiers: type 2 is the issuer whose signature verification key can be identified only pair-wise with the holder / verifier
    \end{itemize}
	& \begin{itemize}
		\item The credentials issued by type 1 issuers can be used in proofs to unrelated parties
    \item The credentials issued by type 2 issuers can only be used in proofs to parties who know the issuer in question.
		\end{itemize}
	& \begin{itemize}
    \item If ring signatures are used, the type one issuer identifiers would not imply that the identity of the issuer can be linked to a credential, it would only mean that “Key K\_a belongs to company A”
    \item Otherwise, only the type two issuers would be anonymous and unlinkable to credentials
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\hline
		\textbf{Credential Issuance}
	& Blind signatures: the issuer signs on a commitment of a self-attested credential after seeing a proof of correct attestation; a second kind of proof would be needed in the system
	& \begin{itemize}
    \item The proof of correct attestation must contain the structure, data types, ranges and credential type that the issuer allows
    \item In some cases, the proof must contain verification of the attributes themselves (e.g.: address is in Florida, but not know the city)
			\begin{itemize}
				\item The proof of credential must not be accepted if the signature of the 	credential was not verified either in zero-knowledge or as part of some public verification
			\end{itemize}
		\end{itemize}
	& \begin{itemize}
    \item Issuer’s signatures on credentials add limited legitimacy: a holder could add specific values / attributes that are not real and the issuer would not know
    \item An Issuer can collude with a holder to produce blind signatures without the issuer being blamed
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\cline{2-5}
	& In the clear signatures: the issuer generates the attestation, signing the commitment and sending the credential in the clear to the holder 
	& \begin{itemize}
		\item The proof of credential must not be accepted if the signature of the credential was
	not verified either in zero-knowledge or as part of some public verification
		\end{itemize}
	& \begin{itemize}
    \item Issuer must be trusted, since she can see the Holder’s data and could share it with others
    \item The signature of the issuer can be trusted and blame could be allocated to the issuer
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\hline
		\textbf{Credential Revocation}
	& Positive accumulator revocation: the issuer revokes the credential by removing an element from an accumulator
	& \begin{itemize}
		\item The holder must prove set membership of a credential to prove it was issued and was not revoked at the same time
		\item The issuer can revoke a credential by removing the element that represents it from the accumulator
		\end{itemize}
	& \begin{itemize}
		\item If the accumulator is maintained by a central authority, then only the authority can link the revocation to the original issuance, avoiding timing attacks by general parties (join-revoke linkability)
		\item If the accumulator is maintained through a public state, then there can be linkability of revocation with issuance since one can track the added values and test its membership
		\end{itemize}
  & \cite{2017:ccs:Practical-UC-Secure-Delegatable-Credentials-with-attributes} \rowend
%%%%%%%%%%%%
\cline{2-5}
	& Negative accumulator revocation: the issuer revokes by adding an element to an accumulator
	& \begin{itemize}
		\item The holder must prove set membership of a credential to prove it was issued
		\item The issuer can revoke a credential by adding to the negative accumulator the revocation secret related to the credential to be revoked
		\item The holder must prove set non-membership of a revocation secret 	
		associated to the credential in question
		\item The verifier must use the most recent version of the accumulator to validate the claim
		\end{itemize}
	& \begin{itemize}
		\item Even when the accumulator is maintained through a public state, the revocation cannot be linked to the issuance since the two events are independent of each other
		\end{itemize}
	& \rowend
%%%%%%%%%%%%
\hline
\end{funcprivtabular}

\end{landscape}
} %end of \afterpage

\paragraph{Gadgets.}

Each of the methods for instantiating the different functionalities use some of the following gadgets that have been described in the Gadgets section. There are three main parts to the predicate of any proof.
\begin{enumerate}
\item The first is proving the veracity of the identity, in this case the holder, for which the following gadgets can / should be used:
		\begin{itemize}
		\item \textbf{Commitment} for checking that the identity has been attested 			to correctly.
		\item \textbf{PRF} for proving the preimage of the identifier is known by the holder
		\item \textbf{Equality of strings} to prove that the new identifier has a connection to the previous identifier used or to an approved identifier.\
		\end{itemize}

\item Then there is the part of the constraint system that deals with the legitimacy of the credentials, the fact that it was correctly issued and was not revoked. 	
		\begin{itemize}
		\item \textbf{Commitment} for checking that the credential was correctly committed to.	
		\item \textbf{PRF} for proving that the holder knows the credential information, which is the preimage of the commitment .
		\item \textbf{Equality of strings} to prove that the credential was issued to an identifier connected to the current identifier.
		\item \textbf{Accumulators (Set membership / non-membership)} to prove that the commitment to the credential exists in some set (usually an accumulator), implying that it was issued correctly and that it was not revoked.
		\end{itemize}

\item Finally there is the logic needed to verify the rules / constraints imposed on the attributes themselves. This part can be seen as a general gadget called “credentials”, which allows to verify the specific attributes embedded in a credential. Depending on the 	credential type, it uses the following low level gadgets:	
		\begin{itemize}
		\item \textbf{Data Type} used to check that the data in the credential is of the correct type 	
		\item \textbf{Range Proofs} used to check that the data in the credential is within some range
		\item \textbf{Arithmetic Operations (field arithmetic, large integers, etc.)} used for verifying arithmetic operations were done correctly in the computation of the instance.
		\item \textbf{Logical Operators (bigger than, equality, etc.)} used for comparing some value in the instance to the data in the credentials or some computation derived from it.
		\end{itemize}
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Security caveats}

\begin{enumerate}
	\item If the Issuer colludes with the Verifier, they could use the revocation mechanism to reveal information about the Holder if there is real-time sharing of revocation information.
	\item Furthermore, if the commitments to credentials and the revocation 	information can be tracked publicly and the events are dependent of each other (e.g.: revocation by removing a commitment), then there can be linkability between issuance and revocation.	
	\item In the case of self-attestation or collusion between the issuer and the holder, there is a much lower assurance of data integrity. The inputs to the ZKP could be spoofed and then the proof would not be sound.
	\item The use of Blockchains create a reliance on a trusted oracle for external state. On the other hand, the privacy guaranteed at blockchain-content level is orthogonal to network-level traffic analysis.	
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\subsection{A use-case example of credential aggregation}


\paragraph{Use-case description.}
As a way to illustrate the above protocol, we present a specific use-case and explicitly write the predicate of the proof. Mainly, there is an identity, Alice, who wants to prove to some company, Bob Inc. that she is an accredited investor, under the SEC rules, in order to acquire some company shares. Alice is the prover; the IRS, the AML entity and The Bank are all issuers; and Bob Inc. is the verifier.

The different processes in the adaptation of the use-case are the following:

\begin{enumerate}
\item Three confidential credentials are issued to Alice which represent the rules that we apply on an entity to be an accredited investor\footnote{We assume that the SEC generates the constraint system for the accreditation rules as the circuit used to generate the proving and verification keys. In the real scenario, here are the \href{https://www.ecfr.gov/cgi-bin/retrieveECFR?gp=&SID=8edfd12967d69c024485029d968ee737&r=SECTION&n=17y3.0.1.1.12.0.46.176}{Federal Rules for accreditation}.}:
		\begin{enumerate}
        \item The IRS issues a tax credential, $C_0$, that testifies to the claim “from 1/1/2017 until 1/1/2018, Alice, with identifier $X_0$, ows 0\$ to the IRS, with identifier $Y$” and holds two attributes: the net income of Alice, \$income, and a bit $b$ such that $b=1$ if Alice has paid her taxes.
        \item The AML entity issues a KYC credential, $C_1$, that testifies to claim $T_1$:= “Alice, with identifier $X_1$, has NO relation to a (set of) blacklisted organization(s)”
        \item The Bank issues a net-worth credential, $C_2$, that testifies to claim $T_2$:= “Alice has a net worth of $V\textsubscript{Alice}$”
		\end{enumerate}
\item Alice then proves to Bob Inc. that:
    \begin{enumerate}
				\item “Alice’s identifier, $X\textsubscript{Bob}$, is related to the identifiers, {$X_i$} for $i = 0, 1, 2$ that are connected to the confidential credentials {$C_i$}”
        \item “I know the credentials, which are the preimage of some commitment, {$C_i$}, were issued by the legitimate issuers”
        \item “The credentials, which are the preimage of some commitment, {$C_i$}, that exist in an accumulator, $U$, satisfy the three statements {$T_i$}”
		\end{enumerate}
\end{enumerate}



\paragraph{Instantiation details.}
Based on the different options laid out in the table above, the following have been used:

\begin{itemize}
    \item \underline{Holder identification:} we instantiate the identifiers as a unique anonymous identifier, publicKey
    \item \underline{Issuance identification:} the identity of the issuers is known to all the participants, who can publicly verify the signature on the credentials they issue\footnote{With public signature verification keys that are hard coded into the circuit}.
    \item \underline{Credential issuance:} credentials are issued by publishing a signed commitment to a positive accumulator and sharing the credential in the clear to Alice.
    \item \underline{Credential revocation:} is done by removing the commitment of credential from a dynamic and positive accumulator. 
		Alice must prove membership of commitment to show her credential was not revoked.
    \item \underline{Credential verification:} Bob Inc. then verifies the cryptographic proof with the instance.
\end{itemize}


\mbox{}\\
Note that the transfer of company shares as well as the issuance of company shares is outside of the scope of this use-case, but one could use the “Asset Transfer” section of this document to provide that functionality. 

On another note, the fact that the proving and verification keys were validated by the SEC is an assurance to Bob Inc. that proof verification implies Alice is an accredited investor.


\paragraph{The Predicate}
\begin{itemize}
\item \blue{Blue = publicly visible in protocol / statement}
\item \red{Red = secret witness, potentially shared between parties when proving}
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%
\textbf{Definitions / Notation:}


Public state: \blue{Accumulator}, for issuance and revocation, which includes all the commitments to the credentials.


\vspace{.5em}
\red{ConfCred} = Commitment to Cred = \{ \blue{Revoke}, \red{certificateType, publicKey, Attribute(s)}  \}

Where, again, the IRS, AML and Bank are authorities with well-known public keys. Alice’s \red{publicKey} is her long term public key and one cannot create a new credential unless her long term ID has been endorsed. The goal of the scheme is for the holder to create a fresh \textbf{proof of confidential aggregated credentials to the claim of accredited investor}.

\def\subIRS{\textsubscript{IRS}}
\def\subAML{\textsubscript{AML}}
\def\subrhIRS{\textsubscript{rhIRS}}
\def\subrhAML{\textsubscript{rhAML}}


IRS issues a \red{ConfCred\subIRS} = Commitment( openIRS, revokeIRS, “IRS”, myID, \$Income, b ), sigIRS
AML issues \red{ConfCred\subAML}= Commitment( openAML, revokeAML, “AML”, myID, “OK”), sigAML

Holder generates a fresh public key \blue{freshCred} to serve as an ephemeral blinded aggregate credential, and a ZKP of the following:

\textbf{ZkPoK}\{  (witness: \red{myID, ConfCred\subIRS, ConfCred\subAML, sigIRS, sigAML, \$Income, , mySig, open\subIRS, open\subAML} statement: \blue{freshCred, minIncomeAccredited} ) :  
Predicate: 
	\begin{itemize}[label={- }]
		\item \red{ConfCred\subIRS} is a commitment to the IRS credential  ( \red{open\subIRS}, \blue{“IRS”}, \red{myID, \$Income} )
		\item \red{ConfCred\subAML} is the AML crdential to ( \red{open\subAML}, \blue{“AML”}, \red{myID}, \blue{“OK”} )
		\item \red{\$Income} >= \blue{minIncomeAccredited}
		\item \red{b} = 1 = “myID paid full taxes”
		\item \red{mySig} is a signature on \blue{freshCred} for \red{myID}
		\item \textbf{ProveNonRevoke(  )}
	\end{itemize}

\hphantom{\textbf{ZkPoK}}\}


Present the credential to relying party:\luiscom{The term ``relying party'' requires prior definition.}
\blue{freshCred} and \textbf{zkp}.



\vspace{.5em}\textbf{ProveNonRevoke}( rhIRS, w\_hrIRS, rhAML, w\_hrAML, a\_IRS
\begin{itemize}
    \item \red{revokeIRS}: revocation handler from IRS. Can be embedded as an attribute in \red{ConfCredt\subIRS} and is used to handle revocations.
    \item \red{wit\subrhIRS}: accumulator witness of \red{revokeIRS}.
    \item \red{revokeAML}: revocation handler from AML. Can be embedded as an attribute in \red{ConfCredt\subAML} and is used to handle revocations.
    \item \red{wit\subrhAML}: accumulator witness of \red{revokeAML}.
    \item \blue{acc\subIRS}: accumulator for IRS.
    \item \blue{CommRevoke\subIRS}: commitment to \red{revokeIRS}. The holder generates a new commitment for each revocation to avoid linkability of proofs. 
    \item \blue{acc\subAML}: accumulator for AML.
    \item \blue{CommRevoke\subAML}: commitment to \red{revokeAML}. The holder generates a new commitment for each revocation to avoid linkability of proofs. 
\end{itemize}


\vspace{.5em}
\textbf{ZkPoK}\{ (witness: \red{rhIRS, open\subrhIRS, w\subrhIRS, rhAML, open\subrhAML, w\subrhAML}|| statements: \blue{C\subIRS, a\subIRS , C\subAML , a\subAML} ):
Predicate:
	\begin{itemize}[label={- }]
	\item \blue{C\subIRS} is valid commitment to ( \red{open\subrhIRS, rhIRS} )
	\item \red{rhIRS} is part of accumulator \red{a\subIRS}, under witness \red{w\subrhIRS}
	\item \red{rhIRS} is an attribute in \red{Cert\subIRS}
	\item \blue{C\subAML} is valid commitment to ( \red{open\subrhAML, rhAML} )
	\item \red{rhAML} is part of accumulator \blue{a\subAML}, under witness \red{w\subrhAML}
	\item \red{rhAML} is an attribute in \red{Cert\subAML}
	\end{itemize}
\hphantom{\textbf{ZkPoK}}\}

	\begin{itemize}
		\item[- ] myCred is unassociated with myID, with sigIRS, sigAML etc.
    \item[- ] Withstands partial compromise: even if IRS leaks myID and sigIRS, it cannot be used to reveal the sigAML or associated myID with myCred
	\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Asset Transfer}

\subsection{Privacy-preserving asset transfers and balance updates}

In this section, we examine two use-cases involving using ZK Proofs (ZKPs) to facilitate private asset-transfer for transferring fungible or non-fungible digital assets.  These use-cases are motivated by privacy-preserving cryptocurrencies, where users must prove that a transaction is valid, without revealing the underlying details of the transaction.  We explore two different frameworks, and outline the technical details and proof systems necessary for each.

There are two dominant paradigms for tracking fungible digital assets, tracking ownership of assets individually, and tracking account balances.  The Bitcoin system introduced a form of asset-tracking known as the UTXO model, where Unspent Transaction Outputs correspond roughly to single-use “coins”.  Ethereum, on the other hand, uses the balance model, and each account has an associated balance, and transferring funds corresponds to decrementing the sender’s balance, and incrementing the receiver’s balance accordingly. 

These two different models have different privacy implications for users, and have different rules for ensuring that a transaction is valid.  Thus the requirements and architecture for building ZK proof systems to facilitate privacy-preserving transactions are slightly different for each model, and we explore each model separately below.

In its simplest form, the asset-tracking model can be used to track non-fungible assets.  In this scenario, a transaction is simply a transfer of ownership of the asset, and a transaction is valid if: the sender is the current owner of the asset.  In the balance model (for fungible assets), each account has a balance, and a transaction decrements the sender’s account balance while simultaneously incrementing the receivers.  In a “balance” model, a transaction is valid if 1) The amount the sender’s balance is decremented is equal to the amount the receiver’s balance is incremented, 2) The sender’s balance remains non-negative 3) The transaction is signed using the sender’s key.

\subsection{Zero-Knowledge Proofs in the asset-tracking model}

In this section, we describe a simple ZK proof system for privacy-preserving transactions in the asset-tracking (UTXO) model.  The architecture we outline is essentially a simplification of the ZCash system.  The primary simplification is that we assume that each asset (“coin”) is indivisible.  In other words, each asset has an owner, but there is no associated value, and a transaction is simply a transfer of ownership of the asset.

\textbf{Motivation:} Allow stakeholders to transfer non-fungible assets, without revealing the ownership of the assets publicly, while ensuring that assets are never created or destroyed.

\textbf{Parties:} There are three types of parties in this system: a Sender, a Receiver and a distributed set of validators.  The sender generates a transactions and a proof of validity.  The (distributed) validators act as verifiers and check the validity of the transaction.  The receiver has no direct role, although the sender must include the receiver’s public-key in the transaction.

\textbf{What is being proved:} At high level, the sender must prove three things to convince the validators that a transaction is valid.
\begin{itemize}
 \item The asset (or “note”) being transferred is owned by the sender.  (Each asset is represented by a unique string)
 \item The sender proves that they have the private spending keys of the input notes, giving them the authority to send asset.
 \item The private spending keys of the input assets are cryptographically linked to a signature over the whole transaction, in such a way that the transaction cannot be modified by a party who did not know these private keys.
\end{itemize}

\textbf{What information is needed by the verifier:}
\begin{itemize}
 \item The verifiers need access  to the CRS used by the proof system
 \item The validators need access to the entire history of transactions (this includes all UTXOs, commitments and nullifiers as described later).  This history can be stored on a distributed ledger (e.g. the Bitcoin blockchain)
\end{itemize}
		
		
\textbf{Possible attacks:}
\begin{itemize}
 \item CRS compromise: If an attacker learns the private randomness used to generate the CRS, the attacker can forge proofs in the underlying system
 \item Ledger attacks: validating a transaction requires reading the entire history of transactions, and thus a verifier with an incorrect view of the transaction history may be convinced to accept an incorrect transaction as valid.
 \item Re-identification attacks: The purpose of incorporating ZKPs into this system is to facilitate transactions without revealing the identities of the sender and receiver.  If anonymity is not required, ZKPs can be avoided altogether, as in Bitcoin.  Although this system hides the sender and receiver of each transaction, the fact that a transaction occurred (and the time of its occurrence) is publicly recorded, and thus may be used to re-identify individual users.
 \item IP-level attacks: by monitoring network traffic, an attacker could link transactions to specific senders or receivers (each transaction requires communication between the sender and receiver) or link public-keys (pseudonyms) to real-world identities
 \item Man-it-the-Middle attacks: An attacker could convince a sender to transfer an asset to an “incorrect” public-key
\end{itemize}


\emph{\textbf{Setup scenario:}}  This system is essentially a simplified version of Zcash proof system, modified for indivisible assets.  Each asset is represented by a unique AssetID, and for simplicity we assume that the entire set of assets has been distributed, and no assets are ever created or destroyed.

At any given time, the public state of the system consists of a collection of “asset notes”.  These notes are stored as leaves in a Merkle Tree, and each leaf represents a single indivisible asset represented by unique assetID.  In more detail, a “note” is a commitment to { Nullifier, publicKey, assetID }, indicating that publicKey “owns” assetID.


\paragraph{Main transaction type:} 
Sending an asset from Current Owner $A$ to New Owner $B$

\paragraph{Security goals:}
  \begin{itemize} 
		\item Only the current owner can transfer the asset
    \item Assets are never created or destroyed
	\end{itemize}

\paragraph{Privacy goals:} 
Ideally, the system should hide all information about the ownership and transaction patterns of the users.
The system sketched below does not attain that such a high-level of privacy, but instead achieves the following privacy-preserving features
   \begin{itemize}
		\item Transactions are publicly visible, i.e., anyone can see that a transaction occurred
    \item Transactions do not reveal which asset is being transferred
    \item Transactions do not reveal the identities (public-keys) of the sender or receiver.
			\begin{itemize}
        \item Limitation: Previous owner can tell when the asset is transferred.  (Mitigation: after receiving asset, send it to yourself)
			\end{itemize}
	\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Details of a transfer:}

	Each transaction is intended to transfer ownership of an asset from a Current Owner to a New Owner.  
	In this section, we outline the proofs used to ensure the validity of a transaction. 
	Throughout this description, we use \blue{Blue} to denote information that is globally and \blue{publicly} visible in the protocol / statement.  
	We use \red{Red} to denote \red{private} information, e.g. a secret witness held by the prover or information shared between the Current Owner and New Owner.

The Current Owner, $A$, has the following information
	\begin{itemize}
    \item A \red{publicKey} and corresponding \red{secretKey}
    \item An assetID corresponding to the asset being transferred
    \item A \blue{note} in the MerkleTree corresponding to the asset
    \item Knows how to open the \red{commitment} (\blue{Nullifier}, \red{assetID, publicKey}) \red{publicKeyOut} of the new Owner $B$
	\end{itemize}

The Current Owner, $A$, generates
	\begin{itemize}
    \item A new \red{NullifierOut}
    \item A new commitment \red{commitment (NullifierOut, assetID, publicKey)}
	\end{itemize}

The Current owner, $A$, sends
	\begin{itemize}
    \item Privately to $B$: \red{NullifierOut, publicKeyOut, assetID}
    \item Publicly to the blockchain: \blue{Nullifier, comOut, ZKProof} (the structure of \blue{ZKProof} is outlined below)
	\end{itemize}

If \blue{Nullifier} does not exist in \blue{MerkleTree} and and \blue{ZKProof} validates, then \blue{comOut} is added to the merkleTree.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{The structure of the Zero-Knowledge Proof:}

We use a modification of \href{https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/69316/eth-3353-01.pdf}{Camenisch-Stadler} notation to describe the describe the structure of the proof.

Public state: \blue{MerkleTree} of Notes:
Note = \red{Commitment} to \{ \blue{Nullifier}, \red{publicKey, assetID} \}

\blue{ZKProof} = ZkPoK\textsubscript{pp}\{  
\begin{itemize}
\item[] (witness: publicKey, publicKeyOut, merkleProof, NullifierOut, com, assetID, sig
\item[] statement: MerkleTree, Nullifier, comOut ) :  
\item[] predicate: 
		\begin{itemize} 
			\item[-] \red{com} is included in \blue{MerkleTree} (using \red{merkleProof})
			\item[-] \red{com} is a commitment to ( \blue{Nullifier}, \red{publicKey, assetID} )
			\item[-] \blue{comOut} is a commitment to ( \red{NullifierOut, publicKeyOut, assetID} )
			\item[-] \red{sig} is a signature on \blue{comOut} for \red{publicKey}
		\end{itemize}
\end{itemize}
\hphantom{\blue{ZKProof} = ZkPoK\textsubscript{pp}}\}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Zero-Knowledge proofs in the balance model}

In this section, we outline a simple system for privately transferring fungible assets, in the “balance model.”  This system is essentially a simplified version of \href{https://www.usenix.org/system/files/conference/nsdi18/nsdi18-narula.pdf}{zkLedger}.  The state of the system is an (encrypted) account balance for each user.  Each account balance is encrypted using an additively homomorphic cryptosystem, under the account-holder’s key.  A transaction decrements the sender’s account balance, while incrementing the receiver’s account by a corresponding amount.  If the number of users is fixed, and known in advance, then a transaction can hide all information about the sender and receiver by simultaneously updating all account balances.  This provides a high-degree of privacy, and is the approach taken by zkLedger.  If the set of users is extremely large, dynamically changing, or unknown to the sender, the sender must choose an “anonymity set” and the transaction will reveal that it involved members of the anonymity set, but not the amount of the transaction or which members of the set were involved.  For simplicity of presentation, we assume a model like zkLedger’s where the set of parties in the system is fixed, and known in advance, but this assumption does not affect the details of the zero-knowledge proofs involved.

\textbf{Motivation:} Each entity maintains a private account balance, and a transaction decrements the sender’s balance and increments the receiver’s balance by a corresponding amount.  We assume that every transaction updates every account balance, thus all information the origin, destination and value of a transaction will be completely hidden.  The only information revealed by the protocol is the fact that a transaction occurred.

\textbf{Parties:}
\begin{itemize}
    \item A set of n stakeholders who wish to transfer fungible assets anonymously
    \item The stakeholder who initiates the transaction is called the “prover” or the “sender”
    \item The receiver, or receivers do not have a distinguished role in a transaction
    \item A set of validators who maintain the (public) state of the system (e.g. using a blockchain or other DLT).
\end{itemize}


\textbf{What is being proved:} The sender must convince the validators that a proposed transaction is “valid” and the state of the system should be updated to reflect the new transaction.  A transaction consists of a set of n ciphertexts, $(c_1, \ldots, c_n)$, and where $c_i$ = Enc$_{pk}(x_i)$, and a transaction is valid if:\loosen
	\begin{itemize}
    \item The sum of all committed values is 0 (i.e., $x_1 + \cdots + x_n = 0$)
    \item The sender owns the private key corresponding to all negative $x_i$
    \item After the update, all account balances remain positive
	\end{itemize}

What information is needed by the verifier:
	\begin{itemize}
    \item The verifiers need access  to the CRS used by the proof system
    \item The verifiers need access to the current state of the system (i.e., the current vector of $n$ encrypted account balances).  
		This state can be stored on a distributed ledger
	\end{itemize}

Possible attacks:
	\begin{itemize}
    \item CRS compromise: If an attacker learns the private randomness used to generate the CRS, the attacker can forge proofs in the underlying system
    \item Ledger attacks: validating a transaction requires knowing the current state of the system (encrypted account balances), thus a validator with an incorrect view of the current state may be convinced to accept an incorrect transaction as valid.
    \item Re-identification attacks: The purpose of incorporating ZKPs into this system is to facilitate transactions without revealing the identities of the sender and receiver.  If anonymity is not required, ZKPs can be avoided altogether, as in Bitcoin.  Although this system hides the sender and receiver of each transaction, the fact that a transaction occurred (and the time of its occurrence) is publicly recorded, and thus may be used to re-identify individual users.
    \item IP-level attacks: by monitoring network traffic, an attacker could link transactions to specific senders or receivers (each transaction requires communication between the sender and the validators) or link public-keys (pseudonyms) to real-world identities
    \item Man-it-the-Middle attacks: An attacker could convince a sender to transfer an asset to an “incorrect” public-key.  This is perhaps less of a concern in the situation where the user-base is static, and all public-keys are known in advance.
	\end{itemize}


\paragraph{Setup scenario:} 
There are fixed number of users, $n$.  
User $i$ has a known public-key, $pk_i$.
Each user has an account balance, maintained as an additively homomorphic encryption of their current balance under their $pk$.
Each transaction is a list of $n$ encryptions, corresponding to the amount each balance should be incremented or decremented by the transaction.
To ensure money is never created or destroyed, the plaintexts in an encrypted transaction must sum to 0.
We assume that all account balance are initialized to non-negative values.


\paragraph{Main transaction type:} 
Transferring funds from user $i$ to user $j$


\paragraph{Security goals:}
    \begin{itemize}
		\item An account balance can only be decremented by the owner of that account
    \item Account balances always remain non-negative
    \item The total amount of money in the system remains constant
		\end{itemize}


\paragraph{Privacy goals:}
Ideally, the system should hide all information about the ownership and transaction patterns of the users.
The system sketched below does not attain that such a high-level of privacy, but instead achieves the following privacy-preserving features:
    \begin{itemize}
		\item Transactions are publicly visible, i.e., anyone can see that a transaction occurred
    \item Transactions do not reveal which asset is being transferred
    \item Transactions do not reveal the identities (public-keys) of the sender or receiver.

		Limitation: transaction times are leaked
		\end{itemize}



\paragraph{Details of a transfer:}

Each transaction is intended to update the current account balances in the system.  In this section, we outline the proofs used to ensure the validity of a transaction.  Throughout this description, we use \blue{Blue} to denote information that is globally and \blue{publicly} visible in the protocol / statement.  We use \red{Red} to denote \red{private} information, e.g. a secret witness held by the prover.

The Sender, $A$, has the following information
	\begin{itemize}
    \item Public keys \blue{$pk_1,\ldots,pk_n$}
    \item \red{secretKey$_i$} corresponding to \red{publicKey$_i$}, and a values \red{$x_j$}, to transfer to user $j$
    \item The sender’s own current account balance, \red{$y_i$}
	\end{itemize}

The Sender, $A$, generates
	\begin{itemize}
    \item a vector of ciphertexts, \blue{$C_1,\ldots,C_n$} with \blue{$C_t$} = Enc$_{\blue{pk_t}}(\red{x_t})$
	\end{itemize}

The Sender, $A$, sends
	\begin{itemize}
    \item The vector of ciphertexts \blue{$C_1,\ldots,C_n$} and \blue{ZKProof} (described below) to the blockchain
	\end{itemize}

ZK Circuit: 

Public state: The current state of the system, i.e., a vector of (encrypted) account balances, \blue{$B_1,\ldots,B_n$}.

  \blue{ZKProof} = ZkPoK\textsubscript{pp}\{  (witness: \red{$i, x_1, \ldots, x_n, sk$} statement: \blue{$C_1,\ldots,C_n$} ) :

\hspace{1em}predicate: 
\begin{itemize}
\item[-] $C_t$ is an encryption to $x_t$ under public key $pk_t$ for $t=1,\ldots,n$
\item[-] $x_1 + \cdots + x_n = 0$
\item[-] $x_t \geq 0$ OR $sk$ corresponds to $pk_t$ for $t = 1,\ldots,n$
\item[-] $x_t \geq 0$ OR current balance $B_t$ encrypts a value no smaller than $|x_t|$ for $t = 1,\ldots,n$
\end{itemize}
\}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Regulation Compliance}

\subsection{Overview}
An important pattern of applications in which zero-knowledge protocols are useful is within settings in which a regulator wishes to monitor, or assess the risk related to some item managed by a regulated party. One such example can be whether or not taxes are being paid correctly by an account holder, or is a bank or some other financial entity solvent, or even stable. 

The regulator in such cases is interested in learning “the bottom line”, which is typically derived from some aggregate measure on more detailed underlying data, but does not necessarily need to know all the details. For example, the answer to the question of “did the bank take on too many loans?” Is eventually answered by a single bit (Yes/No) and can be answered without detailing every single loan provided by the bank and revealing recipients, their income, and other related data. 

Additional examples of such scenarios include: 
\begin{itemize}
    \item[--] Checking that taxes have been properly paid by some company or person.
    \item[--] Checking that a given loan is not too risky.
    \item[--] Checking that data is retained by some record keeper (without revealing or transmitting the data)
    \item[--] Checking that an airplane has been properly maintained and is fit to fly 
\end{itemize}

The use of Zero knowledge proofs can then allow the generation of a proof that demonstrate the correctness of the aggregate result. The idea is to show something like the following statement: There is a commitment (possibly on a blockchain) to records that show that the result is correct. 

\textbf{Trusting data fed into the computation: }
In order for a computation on hidden data to prove valuable, the data that is fed in must be grounded as well. Otherwise, proving the correctness of the computation would be meaningless. To make this point concrete: A credit score that was computed from some hidden data can be correctly computed from some financial records, but when these records are not exposed to the recipient of the proof, how can the recipient trust that they are not fabricated? 

Data that is used for proofs should then generally be committed to by parties that are separate from the prover, and that are not likely to be colluding with the prover. To continue our example from before: an individual can prove that she has a high credit score based on data commitments that were produced by her previous lenders (one might wonder if we can indeed trust previous lenders to accurately report in this manner, but this is in fact an assumption implicitly made in traditional credit scoring as well).   

The need to accumulate commitments regarding the operation and management of the processes that are later audited using zero-knowledge often fits well together with blockchain systems, in which commitments can be placed in an irreversible manner. Since commitments are hiding, such publicly shared data does not breach privacy, but can be used to anchor trust in the veracity of the data. 


\subsection{An example in depth: Proof of compliance for aircraft}

An operator is flying an aircraft, and holds a log of maintenance operations on the aircraft.  These records are on different parts that might be produced by different companies.
Maintenance and flight records are attested to by engineers at various locations around the world (who we assume do not collude with the operator). \newline
The regulator wants to know that the aircraft is allowed to fly according to a certain set of rules.
(Think of the Volkswagen emissions cheating story.)

The problem: Today, the regulator looks at the records (or has an auditor do so) only once in a while. We would like to move to a system where compliance is enforced in “real time”, however, this reveals the real-time operation of the aircraft if done naively.

Why is zero-knowledge needed? We would like to prove that regulation is upheld, without revealing the underlying operational data of the aircraft which is sensitive business operations. 
Regulators themselves prefer not to hold the data (liability and risk from loss of records), prefer to have companies self-regulate to the extent possible. 

What is the threat model beyond the engineers/operator not colluding?  What about the parts manufacturers?  Regulators?  Is there an antagonistic relationship between the parts manufacturers?

This scheme will work on regulation that isn't vague, such as aviation regulation. In some cases, the rules are vague on purpose and leave room for interpretation.



\subsection{Protocol high level}

\textbf{Parties:} 
\begin{itemize}
    \item Operator / Party under regulation: performs operations that need to comply to a regulation. For example an airline operator that operates aircrafts
    \item Risk bearer / Regulator : verifies that all regulated parties conform to the rules; updates the rules when risks evolve. For example, the FAA regulates and enforces that all aircrafts to be airworthy at all times. For an aircraft owner leasing their assets, they want to know that operation and maintenance does not degrade their asset. Same for a bank that financed an aircraft, where the aircraft is the collateral for the financing.  
    \item Issuer / 3rd party attesting to data: Technicians having examined parts, flight controllers attesting to plane arriving at various locations, embarked equipment providing signed readings of sensors.
\end{itemize}

\textbf{What is being proved:}
\begin{itemize}
    \item The operator proves to the regulator that the latest maintenance data indicates the aircraft is airworthy
    \item The operator proves to the bank that the aircraft maintenance status means it is worth a given value, according to a formula provided by that bank
\end{itemize}

\textbf{What are the privacy requirements?}
\begin{itemize}
    \item An operator does not want to reveal the details of his operations and assets maintenance status to competition
    \item The aircraft identity must be kept anonymous from all parties except the regulators and the technicians.
    \item The technician’s identity must be kept anonymous from the regulator but if needed the operator can be asked to open the commitments for the regulator to validate the reports
\end{itemize}
 
\textbf{The proof predicate:} “The operator is the owner of the aircraft, and knows some signed data attesting to the compliance with regulation rules: all the components are safe to fly”. 
	\begin{itemize}
     \item The plane is made up of the components $x_1, \ldots, x_n$ and for each of the components: 
				\begin{itemize}
            \item There is an legitimate attestation by an engineer who checked the component, and signed it's OK
            \item The latest attestation by a technician is recent: the timestamp of the check was done before date $D$
				\end{itemize}
	\end{itemize}


\textbf{What is the public / private data:}
    \begin{itemize}
		\item Private:
        \begin{itemize}
				\item Identity of the operator
        \item Airplane record
        \item Examination report of the technicians
        \item Identity of the technician who signed the report
				\end{itemize}
    \item Public:
        \begin{itemize}
				\item Commitment to airplane record
				\item 
				\end{itemize}
		\end{itemize}

There is a record for the airplane that is committed to a public ledger, which includes miles flown. \newline
There are records that attest to repairs / inspections by mechanics that are also committed to the ledger. The decommitment is communicated to the operator. These records reference the identifier of the plane.

Whenever the plane flies, the old plane record needs to be invalidated, and a new on committed with extra mileage.  \newline
When a proof of “airworthiness” is required, the operator proves that for each part, the mileage is below what requires replacement, or that an engineer replaced the part (pointing to a record committed by a technician).

\textbf{At the gadget level: }
\begin{itemize}
    \item The prover proves knowledge of a de-commitment of an airplane record (decommitment) 
    \item The record is in the set of records on the blockchain (set membership)
    \item and knowledge of de-commitments for records for the parts (decommitment) that are also in the set of commitments on the ledger (set membership)
    \item The airplane record is not revoked (i.e., it is the most recent one), (requires set non-membership for the set of published nullifiers)
    \item The id of the plane noted in the parts is the same as the id of the plane in the plane record.  (equality) 
    \item The mileage of the plane is lower than the mileage needed to replace each part (range proofs) OTHERWISE 
    \item There exists a record (set membership)that says  that the part was replaced by a technician (validate signature of the technician (maybe use ring signature outside of ZK?))
		\end{itemize}
		
\section{Conclusions}

	\begin{itemize}
    \item[--] The asset transfer and regulation can be used in the identity framework in a way that the additions complete the framework.
    \item[--] External oracles such as blockchain used for storing reference to data commitments
	\end{itemize}


\paragraph{List of references:}\pdfbookmark[1]{List of references}{pdfbkm:apps:list-refs}
	FHE standards \cite{2017:applications-of-homomorphic-encryption},
ZERO CASH \cite{2014:SP:Zerocash},
Baby-zoe \cite{2018:github:baby-zoe},
HAWK \red{\cite{}}; %%%missing reference
ZKledger \cite{2018:NSDI:zkLedger}.
	Other identity references:
Sovrin\textsuperscript{TM} \cite{2018:sovrin}, 
\cite{2014:architecture-for-ABC-technologies}, 
\cite{2017:ccs:Practical-UC-Secure-Delegatable-Credentials-with-attributes},
\cite{2017:SP:Accumulators-with-Applications-to-Anonymity-Preserving-Revocation} (mentioned in \reftab{tab:apps:functionality-vs-privacy-requirements}),
\cite{2010:SCN:Solving-Revocation-with-Efficient-Update-of-Anonymous-Credentials}.


%%%%%Other identity references (ref [4] is mentioned in table on page 11):
%%%%%
%%%%%\begin{itemize}[itemsep=1em]
%%%%%\item[] [1] Sovrin™: A Protocol and Token for Self-Sovereign Identity and Decentralized Trust, \myurl{https://sovrin.org/wp-content/uploads/2018/03/Sovrin-Protocol-and-Token-White-Paper.pdf}
%%%%%
%%%%%\item[] [2] D2.2 - Architecture for Attribute-based Credential Technologies - Final Version, \myurl{https://abc4trust.eu/download/Deliverable\_D2.2.pdf}
%%%%%
%%%%%\item[] [3] \href{https://researcher.watson.ibm.com/researcher/view.php?person=zurich-JCA}{Jan Camenisch}, Manu Drijvers, Maria Dubovitskaya. Practical UC-Secure Delegatable Credentials with Attributes and Their Application to Blockchain. ACM Conference on Computer and Communications Security, 2017.			
%%%%%
%%%%%\item[] [4] Foteini Baldimtsi and Jan Camenisch and Maria Dubovitskaya and Anna Lysyanskaya and Leonid Reyzin and Kai Samelin and Sophia Yakoubov. \href{https://eprint.iacr.org/2017/043.pdf}{Accumulators with Applications to Anonymity-Preserving Revocation}. IEEE European Symposium on Security and Privacy, EuroS\&P 2017, IEEE.	
%%%%%
%%%%%\item[] [5] Camenisch, Jan; Kohlweiss, Markulf; Soriente, Claudio. Solving Revocation with Efficient Update of Anonymous Credentials. Security and Cryptography for Networks, 454--471, 2010.
%%%%%\end{itemize}


