%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Motivation}
\label{apps:intro}
 
In this track we aim to overview existing techniques for building ZKP based systems, including designing the protocols to meet the best-practice security requirements. One can distinguish between high-level and low-level applications, where the former are the protocols designed for specific use-cases and the latter are the underlying operations needed to define a ZK predicate. We call gadgets the sub-circuits used to build the actual constraint system needed for a use-case. In some cases, a gadget can be interpreted as a security requirement (e.g.: using the commitment verification gadget is equivalent to ensuring the privacy of underlying data). 

As we will see, the protocols can be abstracted and generalized to admit several use-cases; similarly, there exist compilers that will generate the necessary gadgets from commonly used programming languages. Creating the constraint systems is a fundamental part of the applications of ZKP, which is the reason why there is a large variety of front-ends available.

In this document, we present three use-cases and a set of useful gadgets to be used within the predicate of each of the three use-cases: identity framework, asset transfer and regulation compliance.\pdfcomment[author={Eran Tromer}]{Missing coverage of recursive composition and Proof-Carrying Data as an important high-level tool (in existing prototypes and emerging real applications).
There's a couple of brief mentions in the Implementation track, but those don't cover the usefulness in applications.}

The design of ZKPs is subject to the tradeoff between functionality and performance. Users would like to have powerful ZKPs, in the sense that the system permits to contruct proofs for any predicate, what leads to the necessity of universal ZKPs. On the other hand, users would like to have efficient constructions. According to Table~\ref{tab:apps:APIS-and-interfaces-by-univ-and-preproc}, it is possible to classify ZKPs as (i) universal or non-universal; (ii) scalable or non-scalable; and (iii) preprocessing or non-preprocessing. Item (i) is related to the functionality of the subjacent ZKP, while items (ii) and (iii) are related to performance. The utilization of zk-SNARKs allows to have universal ZKPs with very efficient verifiers. However, most proposals depend upon an expensive preprocessing, which makes such systems hard to scale for some use-cases. A technique called \textit{Proof-Carrying Data} (PCD), originally proposed in ~\cite{2010:ICS:proof-carrying-data}, allows to obtain \textit{recursive composition} for existing ZKPs in a modular way, which means that zk-SNARKs can be used as a building block to construct scalable and non-preprocessing solutions, thus obtaining not only an efficient verifier, as in zk-SNARKs, but also a prover whose consumption of computational resources is efficient, in particular with respect to memory requirements, as described in~\cite{2017:Alg:Scalable-Zero-Knowledge-Via-Cycles-of-Elliptic-Curves} and in~\cite{2013:Recursive-Composition-and-Bootstrapping-for-SNARKS-and-Proof-carrying-Data}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{What this document is NOT about:}
\begin{itemize}
 \item A unique explanation of how to build ZKP applications
 \item An exhaustive list of the security requirements needed to build a ZKP system
 \item A comparison of front-end tools
 \item A show of preference for some use-cases or others
\end{itemize}

