%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Motivation}
\label{apps:intro}
 
In this track we aim to overview existing techniques for building ZKP-based applications, including designing the protocols to meet best-practice security requirements.\revblock[rev:applications:review-intro-about-applications]{\ref{it:applications:review-intro-about-applications}}
We distinguish between high-level and low-level applications, where the former are the protocols designed for specific use-cases and the latter are the necessary underlying operations or sub-protocols.
Each use case admits a circuit, and we discuss the sub-circuits needed to ensure security and functionality of the protocol.
We refer to the circuits as \emph{predicates} and the sub-circuits as \emph{gadgets}:
\begin{itemize}

\item {\bfseries \hypertarget{def:predicate}{Predicate}:} 
The relation or condition that the statement and witness must satisfy.
Can be represented as a circuit.

\item \revblock[rev:applications:define-predicate-and-gadgets]{\ref{it:editorial:applications-move-notation}}
\textbf{\hypertarget{def:gadget}{Gadget}:} The underlying tools needed to construct the predicate.  
In some cases, a gadget can be interpreted as a security requirement 
(e.g., using the commitment verification gadget is equivalent to ensuring the privacy of underlying data).
\loosen

\end{itemize}


Recall from \refsec{security:syntax}\revblock[rev:applications:move-mention-to-syntax]{\ref{it:editorial:applications-move-notation}}
the syntax of a proof system between a prover and verifier.
As we will see, the protocols can be abstracted and generalized to admit several use-cases; 
similarly, there exist compilers that will generate the necessary gadgets from commonly used programming languages. 
Creating the constraint systems is a fundamental part of the applications of ZKP, which is the reason why there is a large variety of front-end software options available.

In this document, we present three ZKP use-cases: identity framework, asset transfer and regulation compliance and emphasize the incorporation of suitable gadgets to ensure security of these protocols.  



\paragraph{Verifiability type.}\revblock[rev:editorial:applications:verifiability-type]{\ref{it:editorial:applications:verifiability-type}}

When designing ZK based applications, one needs to keep in mind which of the following three models (that define the functionality of the ZKP) is needed:

\begin{enumerate}

    \item \textbf{Public.}
		Publicly verifiable as a requirement: a scheme / use-case where 
	there is a system requirement that
	the proofs are transferable. %%%, where such property is actually a requirement of the system. 
		\revblock[rev:remove-incorrection-on-transferability]{\ref{it:transferability-vs-interactivity-incorrect}}
		%%%Only non-interactive ZK (NIZK) can actually hold this property.\luiscom{Consider revising this assertion, since if transferability is a design goal, it can still be obtained with an interactive protocol.}
		
    \item \textbf{Designated.} 
		Designated verifier as a security feature: only the intended receiver of the proof can verify it, making the proof non-transferable. 
		This property can apply to both interactive and non-interactive ZK.
		
    \item \textbf{Optional.} %The final model is one where neither of the above is needed: a ZK where 
		There is no need to be able to transfer but also no non-transferability requirement. %Again, 
		This property %model 
	can apply both in the interactive and non-interactive model.

\end{enumerate}

For example, digital money based applications belong to the first model,\luiscom{Unclear why. Seems reasonable to devise use-cases where one wants to perform a non-transferable ZKP about something that happened with digital money.} compliance for regulation lives in the second model (albeit depending on the use-case). In general, the credential system can be in both of the last two models, given the extra constraints that would make it belong to the second model.



%%% NOTE LB: Contains minor editorial changes
\paragraph{Functionality vs.\ performance.}
\revblock[rev:app:intro:motivate]{\ref{it:improve-motivation-apps}}
	The design of ZKPs is subject to the tradeoff between functionality and performance. 
	Users would like to have powerful ZKPs, in the sense that the system permits constructing %to construct 
proofs for any predicate, which %what 
leads to the necessity of universal ZKPs. 
	On the other hand, users would like to have efficient constructions. 
	According to Table~\ref{tab:apps:APIS-and-interfaces-by-univ-and-preproc}, it is possible to classify ZKPs as:
(i) universal or non-universal;
(ii) scalable or non-scalable; and 
(iii) preprocessing or non-preprocessing. 
	Item (i) is related to the functionality of the underlying %subjacent 
ZKP, while items (ii) and (iii) are related to performance. 
	The utilization of zk-SNARKs allows %to have 
universal ZKPs with very efficient verifiers. 
	However, many proposals %%% LB editorial: changed ``most'' (which is very contextual to a moment in time) to ``many''
depend upon an expensive preprocessing, which makes such systems hard to scale for some use-cases. 
	A technique called \textit{Proof-Carrying Data} (PCD), originally proposed in Ref.~\cite{2010:ICS:proof-carrying-data},\revblock[rev:app:intro:new-refs]{\ref{it:refs-in-chapter-apps}} 
allows obtaining %to obtain 
\textit{recursive composition} for existing ZKPs in a modular way. %, which
	This means that zk-SNARKs can be used as a building block to construct scalable and non-preprocessing solutions.
	%thus obtaining 
	The result is not only an efficient verifier, as in zk-SNARKs, but also a prover whose consumption of computational resources is efficient, in particular with respect to memory requirements, as described in Refs.~\cite{2017:Alg:Scalable-Zero-Knowledge-Via-Cycles-of-Elliptic-Curves} and~\cite{2013:Recursive-Composition-and-Bootstrapping-for-SNARKS-and-Proof-carrying-Data}.
\loosen


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\revblock[rev:applications:remove-paragraph-not-about]{\ref{it:applications:remove-paragraph-not-about}}
%\paragraph{What this document is NOT about:}
%\begin{itemize}
% \item A unique explanation of how to build ZKP applications
% \item An exhaustive list of the security requirements needed to build a ZKP system
% \item A comparison of front-end tools
% \item A show of preference for some use-cases or others
%\end{itemize}

